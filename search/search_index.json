{"docs":[{"location":"/index.html","text":"","title":"Izumi Toolkit"},{"location":"/index.html#izumi-toolkit","text":"Scaladoc: izumi package","title":"Izumi Toolkit"},{"location":"/manifesto/index.html","text":"","title":"Our approach to productivity"},{"location":"/manifesto/index.html#our-approach-to-productivity","text":"TODO Sorry, this page is not ready yet","title":"Our approach to productivity"},{"location":"/pper/index.html","text":"","title":"PPER Pattern"},{"location":"/pper/index.html#pper-pattern","text":"TODO Sorry, this page is not ready yet","title":"PPER Pattern"},{"location":"/distage/index.html","text":"","title":"DiStage DI"},{"location":"/distage/index.html#distage-di","text":"TODO Sorry, this page is not ready yet","title":"DiStage DI"},{"location":"/idealingua/index.html","text":"","title":"Idealingua DML/IDL"},{"location":"/idealingua/index.html#idealingua-dml-idl","text":"The following examples will show what IdeaLingua looks like and how to use.","title":"Idealingua DML/IDL"},{"location":"/idealingua/index.html#language-reference","text":"","title":"Language Reference"},{"location":"/idealingua/index.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/index.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/index.html#embedded-data-types","text":"Notes\nWhen it’s impossible to represent a numeric type with target language we use minimal numeric type with bigger range When it’s not possible to represent time type or UUID with target language we use string representation","title":"Embedded data types"},{"location":"/idealingua/index.html#scalar-types","text":"Type name Aliases Explanation Scala mapping str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate","title":"Scalar types"},{"location":"/idealingua/index.html#generics","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar keys supported) Map opt[T] Optional value Option set[T] Set (no guarantees for traversal ordering) Set","title":"Generics"},{"location":"/idealingua/index.html#standalone-compiler","text":"The compiler is built as an uberjar and published onto central.\nYou may use https://github.com/coursier/coursier to run it:\n# release\ncoursier launch com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0 -- --help\n\n# snapshot\ncoursier launch -r https://oss.sonatype.org/content/repositories/snapshots/ com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0-SNAPSHOT -- --help\nCommandline examples:\ncoursier launch com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0 -- -s src -t target -L scala=* -L typescript=*\ncoursier launch com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0 -- -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Standalone compiler"},{"location":"/idealingua/index.html#http4s-transport","text":"Most likely you would need to use Kind Projector compiler plugin and partial unification enabled:\nscalacOptions += \"-Ypartial-unification\"\nresolvers += Resolver.sonatypeRepo(\"releases\")\naddCompilerPlugin(\"org.spire-math\" % \"kind-projector\" % \"0.9.6\" cross CrossVersion.binary)\nYou may find a test for the whole http4s pipeline here. Please note that service definitons for that test are implemented manually, you may find them here.","title":"Http4s Transport"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"Notes:\nAll the examples are given in minimal form Omitted things: marshallers, implicit conversions, type info\nWe support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n   name: str\n   surname: str\n }","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData class cannot define fields Data class cannot be subclassed Data class is always redered as DTO/case class, Mixin is always rendered as pair of an Interface and an Implementation\ndata HumanUser {\n   + IdentifiedUser\n   * Person\n }","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n   values: map[str, str]\n }\n \n mixin Failure {\n   message: str\n }\n \n adt Result {\n   Success\n   Failure\n }","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result \n\nobject Result {\n  type Element = Result\n  \n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes: 1. You can use only scalar builtin types for identifier fields 2. We provide both parser and sane .toString implementation 3. .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... 4. Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: dbl\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes: 1. Service signature cannot accept anything except of Mixins (improvements planned) 2. ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation 3. ClientDispatcher just passes input to an abstract receiver 4. ClientWrapper allows you to transform unwrapped method signatures into wrapping instances 5. ServerWrapped provides you an unwrapping service implementation 6. ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.com.github.pshirshov.izumi.idealingua.model._\nimport _root_.com.github.pshirshov.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends com.github.pshirshov.izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n  \n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n  \n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any \n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes: 1. Data classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes: 1. Works same way as polymorphic types 2. Use short names instead of fully qualified names 3. You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/logstage/index.html","text":"","title":"Logstage"},{"location":"/logstage/index.html#logstage","text":"","title":"Logstage"},{"location":"/logstage/index.html#","text":"","title":"Logging contexts"},{"location":"/logstage/index.html#","text":"","title":"Available sink backends"},{"location":"/logstage/index.html#","text":"","title":"Rendering policy"},{"location":"/logstage/index.html#","text":"","title":"Configuration"},{"location":"/logstage/index.html#","text":"","title":"Examples"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit"},{"location":"/sbt/index.html#sbt-toolkit","text":"TODO Sorry, this page is not ready yet","title":"SBT Toolkit"},{"location":"/logstage/contexts.html","text":"","title":""},{"location":"/logstage/sinks.html","text":"","title":""},{"location":"/logstage/sample.html","text":"","title":"Examples"},{"location":"/logstage/sample.html#examples","text":"","title":"Examples"},{"location":"/logstage/sample.html#logstage-config","text":"","title":"Logstage config"},{"location":"/logstage/sample.html#rendering-policy","text":"Input rendering policy (defined in config) is:\npolicy=\"${level}:${ts} ${thread}${location} ${custom-ctx} ${msg}\"\nLet’s send some logs\nval loggerWithContext = logger(\"userId\" -> \"xxx\")\nval loggerWithSubcontext = loggerWithContext(\"custom\" -> \"value\")\n\nval arg = \"this is an argument\"\n\nloggerWithContext.trace(s\"This would be automatically extended\")\nlogger.debug(s\"Service started. argument: $arg, Random value: ${Random.self.nextInt()}\")\nloggerWithSubcontext.info(\"Just a string\")\nlogger.warn(\"Just an integer: \" + 1)\nval arg1 = 5\nlogger.crit(s\"This is an expression: ${2 + 2 == 4} and this is an other one: ${5 * arg1 == 25}\")\nval t = new RuntimeException(\"Oy vey!\")\nlogger.crit(s\"A failure happened: $t\")\nThe final output will be:\nT:2018-05-07T14:31:43.045+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:21) {userId=xxx} This would be automatically extended D:2018-05-07T14:31:43.083+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:22) Service started. argument: arg=this is an argument, Random value: EXPRESSION:scala.util.Random.self.nextInt()=-1725949704 I:2018-05-07T14:31:43.086+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:23) {userId=xxx, custom=value} Just a string; @type=const W:2018-05-07T14:31:43.090+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:24) Just an integer: 1; @type=expr; @expr=\"Just an integer: \".+(1) C:2018-05-07T14:31:43.093+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:26) This is an expression: UNNAMED:true=true and this is an other one: EXPRESSION:5.*(arg1).==(25)=true C:2018-05-07T14:31:43.095+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:28) A failure happened: t=java.lang.RuntimeException: Oy vey! java.lang.RuntimeException: Oy vey! at com.github.pshirshov.izumi.logstage.api.routing.ExampleService.start(LoggingMacroTest.scala:27) at com.github.pshirshov.izumi.logstage.sink.console.LoggingConsoleSinkTest.$anonfun$new$3(LoggingConsoleSinkTest.scala:23) at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)","title":"Rendering policy"},{"location":"/logstage/sample.html#contexts-defintion","text":"","title":"Contexts defintion"},{"location":"/logstage/sample.html#sinks-configuration","text":"","title":"Sinks configuration"},{"location":"/logstage/policy.html","text":"","title":"Rendering policy"},{"location":"/logstage/policy.html#rendering-policy","text":"Rendering policy defines how incoming log event will be transformed into a string. Rendering layout defines in a logstage config section. Rendering policy has string interpolator-like format. Each component (named as Log Unit) defines like ${log_unit_label} in string.","title":"Rendering policy"},{"location":"/logstage/policy.html#log-units-specification","text":"Unit Aliases Explanation Syntax timestamp ts Timestamp ${timestamp} thread t Thread data (contains thread name and id) ${thread} level lvl Logging level ${lvl} location loc Log message location (hyperlink to filename it’s line number) ${location} message msg Application-supplied message associated with the logging event ${message} custom-ctx context, ctx User’s context (more info here) ${custom-ctx} exception ex Outputs the stack trace of the exception associated with the logging event, if any. By default the full stack trace will be output. ${ex}","title":"Log units specification"},{"location":"/logstage/policy.html#parameters","text":"Each log unit has parameters. (example, padding, margins, etc). There are common parameters for all log units and specific for each one. NOTE! Currently there are only common parameters (padding). Parameters enumerates in [ ] braces. For example, ${message[15]}\nLog unit Features Explanation Example common padding padding for log unit in result string. It maybe default padding or ellipsed ([:..14]) ${timestamp}[14]","title":"Parameters"},{"location":"/logstage/policy.html#todo-","text":"define params for each log unit provide intuitive syntax for their definition tests!","title":"TODO:"}]}